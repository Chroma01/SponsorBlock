import { getCurrentPageTitle } from "../../maze-utils/src/elements";
import { getChannelIDInfo, getVideoDuration } from "../../maze-utils/src/video";
import Config from "../config";
import { CategorySelection, CategorySkipOption, SponsorSourceType, SponsorTime } from "../types";
import { getSkipProfile, getSkipProfileBool } from "./skipProfiles";
import { VideoLabelsCacheData } from "./videoLabels";

export interface Permission {
    canSubmit: boolean;
}

export enum SkipRuleAttribute {
    StartTime = "time.start",
    EndTime = "time.end",
    Duration = "time.duration",
    StartTimePercent = "time.startPercent",
    EndTimePercent = "time.endPercent",
    DurationPercent = "time.durationPercent",
    Category = "category",
    ActionType = "actionType",
    Description = "chapter.name",
    Source = "chapter.source",
    ChannelID = "channel.id",
    ChannelName = "channel.name",
    VideoDuration = "video.duration",
    Title = "video.title"
}

export enum SkipRuleOperator {
    Less = "<",
    LessOrEqual = "<=",
    Greater = ">",
    GreaterOrEqual = ">=",
    Equal = "==",
    NotEqual = "!=",
    Contains = "*=",
    NotContains = "!*=",
    Regex = "~=",
    RegexIgnoreCase = "~i=",
    NotRegex = "!~=",
    NotRegexIgnoreCase = "!~i="
}

export interface AdvancedSkipRule {
    attribute: SkipRuleAttribute;
    operator: SkipRuleOperator;
    value: string | number;
}

export interface AdvancedSkipRuleSet {
    rules: AdvancedSkipRule[];
    skipOption: CategorySkipOption;
    comment: string;
}

export function getCategorySelection(segment: SponsorTime | VideoLabelsCacheData): CategorySelection {
    // First check skip rules
    for (const ruleSet of Config.local.skipRules) {
        if (ruleSet.rules.every((rule) => isSkipRulePassing(segment, rule))) {
            return { name: segment.category, option: ruleSet.skipOption } as CategorySelection;
        }
    }

    // Action type filters
    if ("actionType" in segment && (segment as SponsorTime).actionType === "mute" && !getSkipProfileBool("muteSegments")) {
        return { name: segment.category, option: CategorySkipOption.Disabled } as CategorySelection;
    }

    // Then check skip profile
    const profile = getSkipProfile();
    if (profile) {
        const profileSelection = profile.categorySelections.find(selection => selection.name === segment.category);
        if (profileSelection) {
            return profileSelection;
        }
    }

    // Then fallback to default
    for (const selection of Config.config.categorySelections) {
        if (selection.name === segment.category) {
            return selection;
        }
    }
    return { name: segment.category, option: CategorySkipOption.Disabled} as CategorySelection;
}

function getSkipRuleValue(segment: SponsorTime | VideoLabelsCacheData, rule: AdvancedSkipRule): string | number | undefined {
    switch (rule.attribute) {
        case SkipRuleAttribute.StartTime:
            return (segment as SponsorTime).segment?.[0];
        case SkipRuleAttribute.EndTime:
            return (segment as SponsorTime).segment?.[1];
        case SkipRuleAttribute.Duration:
            return (segment as SponsorTime).segment?.[1] - (segment as SponsorTime).segment?.[0];
        case SkipRuleAttribute.StartTimePercent: {
            const startTime = (segment as SponsorTime).segment?.[0];
            if (startTime === undefined) return undefined;

            return startTime / getVideoDuration() * 100;
        }
        case SkipRuleAttribute.EndTimePercent: {
            const endTime = (segment as SponsorTime).segment?.[1];
            if (endTime === undefined) return undefined;

            return endTime / getVideoDuration() * 100;
        }
        case SkipRuleAttribute.DurationPercent: {
            const startTime = (segment as SponsorTime).segment?.[0];
            const endTime = (segment as SponsorTime).segment?.[1];
            if (startTime === undefined || endTime === undefined) return undefined;

            return (endTime - startTime) / getVideoDuration() * 100;
        }
        case SkipRuleAttribute.Category:
            return segment.category;
        case SkipRuleAttribute.ActionType:
            return (segment as SponsorTime).actionType;
        case SkipRuleAttribute.Description:
            return (segment as SponsorTime).description || "";
        case SkipRuleAttribute.Source:
            switch ((segment as SponsorTime).source) {
                case SponsorSourceType.Local:
                    return "local";
                case SponsorSourceType.YouTube:
                    return "youtube";
                case SponsorSourceType.Autogenerated:
                    return "autogenerated";
                case SponsorSourceType.Server:
                    return "server";
                default:
                    return undefined;
            }
        case SkipRuleAttribute.ChannelID:
            return getChannelIDInfo().id;
        case SkipRuleAttribute.ChannelName:
            return getChannelIDInfo().author;
        case SkipRuleAttribute.VideoDuration:
            return getVideoDuration();
        case SkipRuleAttribute.Title:
            return getCurrentPageTitle() || "";
        default:
            return undefined;
    }
}

function isSkipRulePassing(segment: SponsorTime | VideoLabelsCacheData, rule: AdvancedSkipRule): boolean {
    const value = getSkipRuleValue(segment, rule);

    switch (rule.operator) {
        case SkipRuleOperator.Less:
            return typeof value === "number" && value < (rule.value as number);
        case SkipRuleOperator.LessOrEqual:
            return typeof value === "number" && value <= (rule.value as number);
        case SkipRuleOperator.Greater:
            return typeof value === "number" && value > (rule.value as number);
        case SkipRuleOperator.GreaterOrEqual:
            return typeof value === "number" && value >= (rule.value as number);
        case SkipRuleOperator.Equal:
            return value === rule.value;
        case SkipRuleOperator.NotEqual:
            return value !== rule.value;
        case SkipRuleOperator.Contains:
            return String(value).toLocaleLowerCase().includes(String(rule.value).toLocaleLowerCase());
        case SkipRuleOperator.NotContains:
            return !String(value).toLocaleLowerCase().includes(String(rule.value).toLocaleLowerCase());
        case SkipRuleOperator.Regex:
            return new RegExp(rule.value as string).test(String(value));
        case SkipRuleOperator.RegexIgnoreCase:
            return new RegExp(rule.value as string, "i").test(String(value));
        case SkipRuleOperator.NotRegex:
            return !new RegExp(rule.value as string).test(String(value));
        case SkipRuleOperator.NotRegexIgnoreCase:
            return !new RegExp(rule.value as string, "i").test(String(value));
        default:
            return false;
    }
}

export function getCategoryDefaultSelection(category: string): CategorySelection {
    for (const selection of Config.config.categorySelections) {
        if (selection.name === category) {
            return selection;
        }
    }
    return { name: category, option: CategorySkipOption.Disabled} as CategorySelection;
}

type TokenType =
    | "if" // Keywords
    | "disabled" | "show overlay" | "manual skip" | "auto skip" // Skip option
    | keyof typeof SkipRuleAttribute // Segment attributes
    | keyof typeof SkipRuleOperator // Segment attribute operators
    | "and" | "or" // Expression operators
    | "string" // Literal values
    | "eof" | "error"; // Sentinel and special tokens

interface SourcePos {
    line: number;
    // column: number;
}

interface Span {
    start: SourcePos;
    end: SourcePos;
}

interface Token {
    type: TokenType;
    span: Span;
    value: string;
}

interface LexerState {
    source: string;
    start: number;
    current: number;

    start_pos: SourcePos;
    current_pos: SourcePos;
}

function nextToken(state: LexerState): Token {
    function makeToken(type: TokenType): Token {
        return {
            type,
            span: { start: state.start_pos, end: state.current_pos, },
            value: state.source.slice(state.start, state.current),
        };
    }

    /**
     * Returns the UTF-16 value at the current position and advances it forward.
     * If the end of the source string has been reached, returns {@code null}.
     *
     * @return current UTF-16 value, or {@code null} on EOF
     */
    function consume(): string | null {
        if (state.source.length > state.current) {
            // The UTF-16 value at the current position, which could be either a Unicode code point or a lone surrogate.
            // The check above this is also based on the UTF-16 value count, so this should not be able to fail on “weird” inputs.
            const c = state.source[state.current];
            state.current++;

            if (c === "\n") {
                state.current_pos.line++;
                // state.current_pos.column = 1;
            } else {
                // // TODO This will be wrong on anything involving UTF-16 surrogate pairs or grapheme clusters with multiple code units
                // // So just don't show column numbers on errors for now
                // state.current_pos.column++;
            }

            return c;
        } else {
            return null;
        }
    }

    /**
     * Returns the UTF-16 value at the current position without advancing it.
     * If the end of the source string has been reached, returns {@code null}.
     *
     * @return current UTF-16 value, or {@code null} on EOF
     */
    function peek(): string | null {
        if (state.source.length > state.current) {
            // See comment in consume() for Unicode expectations here
            return state.source[state.current];
        } else {
            return null;
        }
    }

    /**
     * Checks the current position against expected UTF-16 values.
     * If any of them matches, advances the current position and returns
     * {@code true}, otherwise {@code false}.
     *
     * @param expected the expected set of UTF-16 values at the current position
     * @return whether the actual value matches and whether the position was advanced
     */
    function expect(expected: string | readonly string[]): boolean {
        const actual = peek();

        if (actual === null) {
            return false;
        }

        if (typeof expected === "string") {
            if (expected === actual) {
                consume();
                return true;
            }
        } else if (expected.includes(actual)) {
            consume();
            return true;
        }

        return false;
    }

    /**
     * Skips a series of whitespace characters starting at the current
     * position. May advance the current position multiple times, once,
     * or not at all.
     */
    function skipWhitespace() {
        let c = peek();
        const whitespace = /s+/;

        while (c != null) {
            if (!whitespace.test(c)) {
                return;
            }

            consume();
            c = peek();
        }
    }

    /**
     * Skips all characters until the next {@code "\n"} (line feed)
     * character occurs (inclusive). Will always advance the current position
     * at least once.
     */
    function skipLine() {
        let c = consume();
        while (c != null) {
            if (c == '\n') {
                return;
            }

            c = consume();
        }
    }

    function isEof(): boolean {
        return state.current >= state.source.length;
    }

    for (;;) {
        skipWhitespace();
        state.start = state.current;

        if (isEof()) {
            return makeToken("eof");
        }

        const c = consume();

        switch (c) {
            // TODO
            default:
                return makeToken("error");
        }
    }
}

export function compileConfig(config: string): AdvancedSkipRuleSet[] | null {
    // TODO
    const ruleSets: AdvancedSkipRuleSet[] = [];
    return ruleSets;
}
