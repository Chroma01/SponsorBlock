import { getCurrentPageTitle } from "../../maze-utils/src/elements";
import { getChannelIDInfo, getVideoDuration } from "../../maze-utils/src/video";
import Config from "../config";
import { CategorySelection, CategorySkipOption, SponsorSourceType, SponsorTime } from "../types";
import { getSkipProfile, getSkipProfileBool } from "./skipProfiles";
import { VideoLabelsCacheData } from "./videoLabels";

export interface Permission {
    canSubmit: boolean;
}

export enum SkipRuleAttribute {
    StartTime = "time.start",
    EndTime = "time.end",
    Duration = "time.duration",
    StartTimePercent = "time.startPercent",
    EndTimePercent = "time.endPercent",
    DurationPercent = "time.durationPercent",
    Category = "category",
    ActionType = "actionType",
    Description = "chapter.name",
    Source = "chapter.source",
    ChannelID = "channel.id",
    ChannelName = "channel.name",
    VideoDuration = "video.duration",
    Title = "video.title"
}

export enum SkipRuleOperator {
    Less = "<",
    LessOrEqual = "<=",
    Greater = ">",
    GreaterOrEqual = ">=",
    Equal = "==",
    NotEqual = "!=",
    Contains = "*=",
    NotContains = "!*=",
    Regex = "~=",
    RegexIgnoreCase = "~i=",
    NotRegex = "!~=",
    NotRegexIgnoreCase = "!~i="
}

export interface AdvancedSkipRule {
    attribute: SkipRuleAttribute;
    operator: SkipRuleOperator;
    value: string | number;
}

export interface AdvancedSkipRuleSet {
    rules: AdvancedSkipRule[];
    skipOption: CategorySkipOption;
    comment: string;
}

export function getCategorySelection(segment: SponsorTime | VideoLabelsCacheData): CategorySelection {
    // First check skip rules
    for (const ruleSet of Config.local.skipRules) {
        if (ruleSet.rules.every((rule) => isSkipRulePassing(segment, rule))) {
            return { name: segment.category, option: ruleSet.skipOption } as CategorySelection;
        }
    }

    // Action type filters
    if ("actionType" in segment && (segment as SponsorTime).actionType === "mute" && !getSkipProfileBool("muteSegments")) {
        return { name: segment.category, option: CategorySkipOption.Disabled } as CategorySelection;
    }

    // Then check skip profile
    const profile = getSkipProfile();
    if (profile) {
        const profileSelection = profile.categorySelections.find(selection => selection.name === segment.category);
        if (profileSelection) {
            return profileSelection;
        }
    }

    // Then fallback to default
    for (const selection of Config.config.categorySelections) {
        if (selection.name === segment.category) {
            return selection;
        }
    }
    return { name: segment.category, option: CategorySkipOption.Disabled} as CategorySelection;
}

function getSkipRuleValue(segment: SponsorTime | VideoLabelsCacheData, rule: AdvancedSkipRule): string | number | undefined {
    switch (rule.attribute) {
        case SkipRuleAttribute.StartTime:
            return (segment as SponsorTime).segment?.[0];
        case SkipRuleAttribute.EndTime:
            return (segment as SponsorTime).segment?.[1];
        case SkipRuleAttribute.Duration:
            return (segment as SponsorTime).segment?.[1] - (segment as SponsorTime).segment?.[0];
        case SkipRuleAttribute.StartTimePercent: {
            const startTime = (segment as SponsorTime).segment?.[0];
            if (startTime === undefined) return undefined;

            return startTime / getVideoDuration() * 100;
        }
        case SkipRuleAttribute.EndTimePercent: {
            const endTime = (segment as SponsorTime).segment?.[1];
            if (endTime === undefined) return undefined;

            return endTime / getVideoDuration() * 100;
        }
        case SkipRuleAttribute.DurationPercent: {
            const startTime = (segment as SponsorTime).segment?.[0];
            const endTime = (segment as SponsorTime).segment?.[1];
            if (startTime === undefined || endTime === undefined) return undefined;

            return (endTime - startTime) / getVideoDuration() * 100;
        }
        case SkipRuleAttribute.Category:
            return segment.category;
        case SkipRuleAttribute.ActionType:
            return (segment as SponsorTime).actionType;
        case SkipRuleAttribute.Description:
            return (segment as SponsorTime).description || "";
        case SkipRuleAttribute.Source:
            switch ((segment as SponsorTime).source) {
                case SponsorSourceType.Local:
                    return "local";
                case SponsorSourceType.YouTube:
                    return "youtube";
                case SponsorSourceType.Autogenerated:
                    return "autogenerated";
                case SponsorSourceType.Server:
                    return "server";
                default:
                    return undefined;
            }
        case SkipRuleAttribute.ChannelID:
            return getChannelIDInfo().id;
        case SkipRuleAttribute.ChannelName:
            return getChannelIDInfo().author;
        case SkipRuleAttribute.VideoDuration:
            return getVideoDuration();
        case SkipRuleAttribute.Title:
            return getCurrentPageTitle() || "";
        default:
            return undefined;
    }
}

function isSkipRulePassing(segment: SponsorTime | VideoLabelsCacheData, rule: AdvancedSkipRule): boolean {
    const value = getSkipRuleValue(segment, rule);

    switch (rule.operator) {
        case SkipRuleOperator.Less:
            return typeof value === "number" && value < (rule.value as number);
        case SkipRuleOperator.LessOrEqual:
            return typeof value === "number" && value <= (rule.value as number);
        case SkipRuleOperator.Greater:
            return typeof value === "number" && value > (rule.value as number);
        case SkipRuleOperator.GreaterOrEqual:
            return typeof value === "number" && value >= (rule.value as number);
        case SkipRuleOperator.Equal:
            return value === rule.value;
        case SkipRuleOperator.NotEqual:
            return value !== rule.value;
        case SkipRuleOperator.Contains:
            return String(value).toLocaleLowerCase().includes(String(rule.value).toLocaleLowerCase());
        case SkipRuleOperator.NotContains:
            return !String(value).toLocaleLowerCase().includes(String(rule.value).toLocaleLowerCase());
        case SkipRuleOperator.Regex:
            return new RegExp(rule.value as string).test(String(value));
        case SkipRuleOperator.RegexIgnoreCase:
            return new RegExp(rule.value as string, "i").test(String(value));
        case SkipRuleOperator.NotRegex:
            return !new RegExp(rule.value as string).test(String(value));
        case SkipRuleOperator.NotRegexIgnoreCase:
            return !new RegExp(rule.value as string, "i").test(String(value));
        default:
            return false;
    }
}

export function getCategoryDefaultSelection(category: string): CategorySelection {
    for (const selection of Config.config.categorySelections) {
        if (selection.name === category) {
            return selection;
        }
    }
    return { name: category, option: CategorySkipOption.Disabled} as CategorySelection;
}

type TokenType =
    | "if" // Keywords
    | "disabled" | "show overlay" | "manual skip" | "auto skip" // Skip option
    | keyof typeof SkipRuleAttribute // Segment attributes
    | keyof typeof SkipRuleOperator // Segment attribute operators
    | "and" | "or" // Expression operators
    | "(" | ")" // Syntax
    | "string" // Literal values
    | "eof" | "error"; // Sentinel and special tokens

interface SourcePos {
    line: number;
    // column: number;
}

interface Span {
    start: SourcePos;
    end: SourcePos;
}

interface Token {
    type: TokenType;
    span: Span;
    value: string;
}

interface LexerState {
    source: string;
    start: number;
    current: number;

    start_pos: SourcePos;
    current_pos: SourcePos;
}

function nextToken(state: LexerState): Token {
    function makeToken(type: TokenType): Token {
        return {
            type,
            span: { start: state.start_pos, end: state.current_pos, },
            value: state.source.slice(state.start, state.current),
        };
    }

    /**
     * Returns the UTF-16 value at the current position and advances it forward.
     * If the end of the source string has been reached, returns <code>null</code>.
     *
     * @return current UTF-16 value, or <code>null</code> on EOF
     */
    function consume(): string | null {
        if (state.source.length > state.current) {
            // The UTF-16 value at the current position, which could be either a Unicode code point or a lone surrogate.
            // The check above this is also based on the UTF-16 value count, so this should not be able to fail on “weird” inputs.
            const c = state.source[state.current];
            state.current++;

            if (c === "\n") {
                state.current_pos.line++;
                // state.current_pos.column = 1;
            } else {
                // // TODO This will be wrong on anything involving UTF-16 surrogate pairs or grapheme clusters with multiple code units
                // // So just don't show column numbers on errors for now
                // state.current_pos.column++;
            }

            return c;
        } else {
            return null;
        }
    }

    /**
     * Returns the UTF-16 value at the current position without advancing it.
     * If the end of the source string has been reached, returns <code>null</code>.
     *
     * @return current UTF-16 value, or <code>null</code> on EOF
     */
    function peek(): string | null {
        if (state.source.length > state.current) {
            // See comment in consume() for Unicode expectations here
            return state.source[state.current];
        } else {
            return null;
        }
    }

    /**
     * Checks the word at the current position against a list of
     * expected keywords. The keyword can consist of multiple characters.
     * If a match is found, the current position is advanced by the length
     * of the keyword found.
     *
     * @param keywords the expected set of keywords at the current position
     * @param caseSensitive whether to do a case-sensitive comparison
     * @return the matching keyword, or <code>null</code>
     */
    function expectKeyword(keywords: readonly string[], caseSensitive: boolean): string | null {
        for (const keyword of keywords) {
            // slice() clamps to string length, so cannot cause out of bounds errors
            const actual = state.source.slice(state.current, state.current + keyword.length);

            if (caseSensitive && keyword === actual || !caseSensitive && keyword.toLowerCase() === actual.toLowerCase()) {
                // Does not handle keywords containing line feeds, which shouldn't happen anyway
                state.current += keyword.length;
                return keyword;
            }
        }

        return null;
    }

    /**
     * Skips a series of whitespace characters starting at the current
     * position. May advance the current position multiple times, once,
     * or not at all.
     */
    function skipWhitespace() {
        let c = peek();
        const whitespace = /\s+/;

        while (c != null) {
            if (!whitespace.test(c)) {
                return;
            }

            consume();
            c = peek();
        }
    }

    /**
     * Skips all characters until the next <code>"\n"</code> (line feed)
     * character occurs (inclusive). Will always advance the current position
     * at least once.
     */
    function skipLine() {
        let c = consume();
        while (c != null) {
            if (c == '\n') {
                return;
            }

            c = consume();
        }
    }

    function isEof(): boolean {
        return state.current >= state.source.length;
    }

    for (;;) {
        skipWhitespace();
        state.start = state.current;
        state.start_pos = state.current_pos;

        if (isEof()) {
            return makeToken("eof");
        }

        const keyword = expectKeyword([
            "if", "and", "or",
            "(", ")",
            "//",
        ].concat(Object.values(SkipRuleAttribute))
            .concat(Object.values(SkipRuleOperator)), true);

        if (keyword !== null) {
            switch (keyword) {
                case "if": return makeToken("if");
                case "and": return makeToken("and");
                case "or": return makeToken("or");

                case "(": return makeToken("(");
                case ")": return makeToken(")");

                case "time.start": return makeToken("StartTime");
                case "time.end": return makeToken("EndTime");
                case "time.duration": return makeToken("Duration");
                case "time.startPercent": return makeToken("StartTimePercent");
                case "time.endPercent": return makeToken("EndTimePercent");
                case "time.durationPercent": return makeToken("DurationPercent");
                case "category": return makeToken("Category");
                case "actionType": return makeToken("ActionType");
                case "chapter.name": return makeToken("Description");
                case "chapter.source": return makeToken("Source");
                case "channel.id": return makeToken("ChannelID");
                case "channel.name": return makeToken("ChannelName");
                case "video.duration": return makeToken("VideoDuration");
                case "video.title": return makeToken("Title");

                case "<": return makeToken("Less");
                case "<=": return makeToken("LessOrEqual");
                case ">": return makeToken("Greater");
                case ">=": return makeToken("GreaterOrEqual");
                case "==": return makeToken("Equal");
                case "!=": return makeToken("NotEqual");
                case "*=": return makeToken("Contains");
                case "!*=": return makeToken("NotContains");
                case "~=": return makeToken("Regex");
                case "~i=": return makeToken("RegexIgnoreCase");
                case "!~=": return makeToken("NotRegex");
                case "!~i=": return makeToken("NotRegexIgnoreCase");

                case "//":
                    skipLine();
                    continue;

                default:
            }
        }

        const keyword2 = expectKeyword(
            [ "disabled", "show overlay", "manual skip", "auto skip" ], false);

        if (keyword2 !== null) {
            switch (keyword2) {
                case "disabled": return makeToken("disabled");
                case "show overlay": return makeToken("show overlay");
                case "manual skip": return makeToken("manual skip");
                case "auto skip": return makeToken("auto skip");
                default:
            }
        }

        const c = consume();

        if (c === '"') {
            // TODO
        } else if (/[0-9.]/.test(c)) {
            // TODO
        }

        return makeToken("error");
    }
}

export function compileConfigNew(config: string): AdvancedSkipRuleSet[] | null {
     // Mutated by calls to nextToken()
    const lexerState: LexerState = {
        source: config,
        start: 0,
        current: 0,

        start_pos: { line: 1 },
        current_pos: { line: 1 },
    };

    let token = nextToken(lexerState);

    while (token.type !== "eof") {
        console.log(token);

        token = nextToken(lexerState);
    }

    // TODO
    return null;
}
